array_each(cb'local (:i32)void:)'void {
  for i : 0i to parent.count {
    cb(
      param0'i32 : param0
    )
  }
}

array_initat(index'i32:, item'i32:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  int32_t* p = (int32_t*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}







class!i32(item1'i32:, item2'i32:)'stack class!i32 {
  this
}

class_each(cb'heap (:i32)void:)'void {
  cb(
    param0'i32 : param0
  )
  cb(
    param0'i32 : param0
  )
}

log(minlevel'loglevel=)'stack log {
  this
}

sum(total'i32=)'heap sum {
  this
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  s'heap sum : heap sum(this = sum(
    total'i32 = total
  ))
  c'stack class!i32 : class!i32(this = class!i32(
    item1'i32 : item1,
    item2'i32 : item2
  ))
  class_each(
    parent: this,
    cb'heap (:i32)void : cb
  )
  a'stack array!i32 : [array_initat(
    parent: this,
    index'i32 : index,
    item'i32 : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'i32 : item
  )]
  array_each(
    parent: this,
    cb'local (:i32)void : cb
  )
  void
}

