array!char(datasize'i32:, data'ptr:, isglobal'bool:, count'i32:)'stack array!char {
  --c--
  if (_this->datasize < 0) {
  halt("size is less than zero");
  }
  if (!_this->data) {
  _this->data = (int*)malloc(_this->datasize * sizeof(char) + sizeof(int)) + 1;
  int* refcount = (int*)_this->data - 1;
  *refcount = 1;
  if (!_this->data) {
  halt("grow: out of memory\n");
  }
  }
  --c--
  this
}

array_grow(newsize'i32:)'stack array!char {
  newdata'ptr = 0
  --c--
  if (_parent->datasize != newsize) {
  if (newsize < _parent->datasize) {
  halt("grow: new size smaller than old _parent->datasize %d:%d\n", newsize, _parent->datasize);
  }
  sjv_newdata = (int*)(malloc(sizeof(int) + newsize * sizeof(char))) + 1;
  int* refcount = (int*)sjv_newdata - 1;
  *refcount = 1;
  if (!_parent->data) {
  halt("grow: out of memory\n");
  }
  char* p = (char*)_parent->data;
  char* newp = (char*)sjv_newdata;
  int count = _parent->count;
  #if true
  memcpy(newp, p, sizeof(char) * count);
  #else
  for (int i = 0; i < count; i++) {
  ;
  }
  #endif
  }
  --c--
  array!char(this = array!char(
    datasize'i32 : datasize,
    data'ptr : data,
    isglobal'bool : isglobal,
    count'i32 : count
  ))
}

array_initat(index'i32:, item'char:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  char* p = (char*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

class(x'i32:)'heap class {
  this
}

hash![type, bool]()'stack hash![type, bool] {
  --cdefine--
  #ifndef type_bool_hash_typedef
  #define type_bool_hash_typedef
  KHASH_INIT_TYPEDEF(type_bool_hash_type, int32_t, bool)
  #endif
  --cdefine--
  --cfunction--
  #ifndef type_bool_hash_function
  #define type_bool_hash_function
  #if false
  KHASH_INIT_FUNCTION_DEREF(type_bool_hash_type, int32_t, bool, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(type_bool_hash_type, int32_t, bool, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(type_bool_hash_type);
  --c--
  this
}

hash![weak class, i32]()'stack hash![class?, i32] {
  --cdefine--
  #ifndef weak_class_i32_hash_typedef
  #define weak_class_i32_hash_typedef
  KHASH_INIT_TYPEDEF(weak_class_i32_hash_type, sjs_class*, int32_t)
  #endif
  --cdefine--
  --cfunction--
  #ifndef weak_class_i32_hash_function
  #define weak_class_i32_hash_function
  #if false
  KHASH_INIT_FUNCTION_DEREF(weak_class_i32_hash_type, sjs_class*, int32_t, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(weak_class_i32_hash_type, sjs_class*, int32_t, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(weak_class_i32_hash_type);
  --c--
  this
}

hash_setat(key'weak class:, val'i32:)'void {
  --c--
  khash_t(weak_class_i32_hash_type)* p = (khash_t(weak_class_i32_hash_type)*)_parent->_hash;
  #if false
  khiter_t k = kh_get(weak_class_i32_hash_type, p, *key);
  #else
  khiter_t k = kh_get(weak_class_i32_hash_type, p, key);
  #endif
  if (k != kh_end(p)) {            
  ;
  }
  int ret;
  #if false
  k = kh_put(weak_class_i32_hash_type, _parent->_hash, *key, &ret);
  #else
  k = kh_put(weak_class_i32_hash_type, _parent->_hash, key, &ret);
  #endif
  if (!ret) kh_del(weak_class_i32_hash_type, p, k);
  #if true
  delete_cb cb = { _parent, (void(*)(void*, void*))INVALID };
  weakptr_cb_add(key, cb);
  #else
  sjs_class* t;
  ;
  #endif
  #if false
  delete_cb cb = { _parent, (void(*)(void*, void*))INVALID };
  weakptr_cb_add(val, cb);
  kh_val(p, k) = val;
  #else
  ;
  #endif
  --c--
}

log(minlevel'loglevel=, traceincludes'stack hash![type, bool]?=, debugincludes'stack hash![type, bool]?=, infoincludes'stack hash![type, bool]?=, warnincludes'stack hash![type, bool]?=, errorincludes'stack hash![type, bool]?=, fatalincludes'stack hash![type, bool]?=)'stack log {
  this
}

string_nullterminate()'void {
  if !parent.data.isglobal || !parent._isnullterminated {
    if parent.count + 1i > parent.data.datasize {
      parent.data'stack array!char = array_grow(
        parent: this,
        newsize'i32 : newsize
      )
    }
    array_initat(
      parent: this,
      index'i32 : index,
      item'char : item
    )
    parent._isnullterminated'bool = true
  }
  void
}

writeline(data'stack string:)'void {
  string_nullterminate(
    parent: this
  )
  --c--
  debugout("%s\n", (char*)data->data.data);
  --c--
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log_includeall'stack hash![type, bool]? : empty'stack hash![type, bool]?
  log_excludeall'stack hash![type, bool]? : value(hash![type, bool](this = hash![type, bool]()))
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel,
    traceincludes'stack hash![type, bool]? = traceincludes,
    debugincludes'stack hash![type, bool]? = debugincludes,
    infoincludes'stack hash![type, bool]? = infoincludes,
    warnincludes'stack hash![type, bool]? = warnincludes,
    errorincludes'stack hash![type, bool]? = errorincludes,
    fatalincludes'stack hash![type, bool]? = fatalincludes
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  clocks_per_sec'i32 = 0i
  --c--
  sjv_clocks_per_sec = CLOCKS_PER_SEC;
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  a'stack hash![class?, i32] : hash![weak class, i32](this = hash![weak class, i32]())
  c'heap class = heap class(this = class(
    x'i32 : x
  ))
  hash_setat(
    parent: this,
    key'weak class : key,
    val'i32 : val
  )
  writeline(
    data'stack string : data
  )
  c'heap class = heap class(this = class(
    x'i32 : x
  ))
  writeline(
    data'stack string : data
  )
  void
}

