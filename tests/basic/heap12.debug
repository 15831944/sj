array!heap class(datasize'i32:, data'ptr:, _isglobal'bool:, count'i32:)'stack array!class {
  --c--
  if (_this->datasize < 0) {
  halt("size is less than zero");
  }
  if (!_this->data) {
  _this->data = malloc(_this->datasize * sizeof(sjs_class*));
  if (!_this->data) {
  halt("grow: out of memory\n");
  }
  }
  --c--
  this
}

array_grow(newsize'i32:)'stack array!class {
  newdata'ptr = 0
  --c--
  if (_parent->datasize != newsize) {
  if (newsize < _parent->datasize) {
  halt("grow: new size smaller than old _parent->datasize %d:%d\n", newsize, _parent->datasize);
  }
  sjv_newdata = malloc(newsize * sizeof(sjs_class*));
  if (!_parent->data) {
  halt("grow: out of memory\n");
  }
  sjs_class** p = (sjs_class**)_parent->data;
  sjs_class** newp = (sjs_class**)sjv_newdata;
  int count = _parent->count;
  for (int i = 0; i < count; i++) {
  ;
  }
  }
  --c--
  array!heap class(this = array!heap class(
    datasize'i32 : datasize,
    data'ptr : data,
    _isglobal'bool : _isglobal,
    count'i32 : count
  ))
}

array_initat(index'i32:, item'heap class:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  sjs_class** p = (sjs_class**)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

list!heap class(array'stack array!class=)'stack list!class {
  this
}

list_add(item'heap class:)'void {
  if parent.array.count >= parent.array.datasize {
    parent.array'stack array!class = copy array_grow(
      parent: this,
      newsize'i32 : newsize
    )
    void
  }
  array_initat(
    parent: this,
    index'i32 : index,
    item'heap class : item
  )
}

log(minlevel'loglevel=)'stack log {
  this
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  a'stack list!class : list!heap class(this = list!heap class(
    array'stack array!class = array
  ))
  for i : 0i to 100i {
    list_add(
      parent: this,
      item'heap class : item
    )
  }
  void
}

