array_getAt(index'i32:)'heap class --c--

if (index >= _parent->size || index < 0) {
printf("getAt: out of bounds\n");
exit(-1);
}
sjs_class_heap** p = (sjs_class_heap**)_parent->data;
;

--c--

array_grow(new_size'i32:)'void {
  --c--
  
  if (_parent->size != new_size) {
  if (new_size < _parent->size) {
  printf("grow: new _parent->size smaller than old _parent->size %d:%d\n", new_size, _parent->size);
  exit(-1);
  }
  
  if (_parent->_isGlobal) {
  _parent->_isGlobal = false;
  sjs_class_heap** p = (sjs_class_heap**)_parent->data;
  _parent->data = (uintptr_t)calloc(new_size * sizeof(sjs_class_heap*), 1);
  if (!_parent->data) {
  printf("grow: out of memory\n");
  exit(-1);
  }
  memcpy((void*)_parent->data, p, _parent->size * sizeof(sjs_class_heap*));
  } else {
  _parent->data = (uintptr_t)realloc((void*)_parent->data, new_size * sizeof(sjs_class_heap*));
  if (!_parent->data) {
  printf("grow: out of memory\n");
  exit(-1);
  }
  memset((sjs_class_heap**)_parent->data + _parent->size, 0, (new_size - _parent->size) * sizeof(sjs_class_heap*));
  }
  _parent->size = new_size;
  }
  
  --c--
  void
}

array_setAt(index'i32:, item'heap class:)'void {
  --c--
  
  if (index >= _parent->size || index < 0) {
  printf("setAt: out of bounds %d:%d\n", index, _parent->size);
  exit(-1);
  }
  sjs_class_heap** p = (sjs_class_heap**)_parent->data;
  p[index]->_refCount--;
  if (p[index]->_refCount <= 0) {
  sjf_class_destroy((sjs_class*)(((char*)p[index]) + sizeof(intptr_t)));
  }
  ;
  ;
  
  --c--
}

list!heap class(count'i32=, data'stack array_heap_class=)'stack list_heap_class {
  this
}

list_add(item'heap class:)'i32 {
  if parent.count > parent.parent.data.size {
    list_setSize(
      parent: parent.parent,
      size'i32 : this.size
    )
    void
  }
  array_setAt(
    parent: parent.parent.parent.data,
    index'i32 : this.index,
    item'heap class : this.item
  )
  parent.parent.parent.parent.count'i32 = parent.parent.parent.parent.parent.count + 1i
}

list_getAt(index'i32:)'heap class {
  array_getAt(
    parent: parent.data,
    index'i32 : this.index
  )
}

list_setSize(size'i32:)'void {
  array_grow(
    parent: parent.data,
    new_size'i32 : this.new_size
  )
}

global()'void {
  a'stack list_heap_class : list!heap class(this = list!heap class(
    count'i32 = this.count,
    data'stack array_heap_class = this.data
  ))
  for x : 1i to 100000i {
    list_add(
      parent: a,
      item'heap class : this.item
    )
  }
  c'heap class : heap list_getAt(
    parent: a,
    index'i32 : this.index
  )
  c.x
  void
}

