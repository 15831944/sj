array_getAt(index'i32:)'heap class c{

		

		if (index >= _parent->size || index < 0) {
			printf("getAt: out of bounds\n");
			exit(-1);
		}

		sjs_class_heap** p = (sjs_class_heap**)_parent->data;
		sjs_class_heap* val = p[index];
#if !false
		if (val == 0) {
			printf("getAt: value is not defined at %d\n", index);
			exit(-1);
		}
#endif
		*_return = val;		
	
}c

array_grow(newSize'i32:)'void c{

		
		

		if (_parent->size != newSize) {
			if (newSize < _parent->size) {
				printf("grow: new size smaller than old size %d:%d\n", newSize, _parent->size);
				exit(-1);
			}
			
			if (_parent->_isGlobal) {
				_parent->_isGlobal = false;
				sjs_class_heap** p = (sjs_class_heap**)_parent->data;
				_parent->data = (uintptr_t)calloc(newSize * sizeof(sjs_class_heap*), 1);
				if (!_parent->data) {
					printf("grow: out of memory\n");
					exit(-1);				
				}
				memcpy((void*)_parent->data, p, _parent->size * sizeof(sjs_class_heap*));
			} else {
				_parent->data = (uintptr_t)realloc((void*)_parent->data, newSize * sizeof(sjs_class_heap*));
				if (!_parent->data) {
					printf("grow: out of memory\n");
					exit(-1);				
				}
				memset((sjs_class_heap**)_parent->data + _parent->size, 0, (newSize - _parent->size) * sizeof(sjs_class_heap*));
			}
			_parent->size = newSize;
		}
	
}c

array_setAt(index'i32:, item'heap class:)'void c{

		

		if (index >= _parent->size || index < 0) {
			printf("setAt: out of bounds %d:%d\n", index, _parent->size);
			exit(-1);
		}

		sjs_class_heap** p = (sjs_class_heap**)_parent->data;
#if !false
		if (p[index] != 0) {
			 p[index]->_refCount--;
if ( p[index]->_refCount <= 0) {
    sjf_class_destroy((sjs_class*)(((char*) p[index]) + sizeof(int)));
}
;
		}
#endif
		 item->_refCount++;
;
		p[index] = item;
	
}c

list!heap class(count'i32=, data'stack array_heap_class=)'stack list_heap_class {
  this
}

list_add(item'heap class:)'i32 {
  if .parentthis.count > this.size {
    list_setSize(
      parent: this,
      size'i32 : this.size
    )
    void
  }
  array_setAt(
    parent: .parentthis.data,
    index'i32 : this.index,
    item'heap class : this.item
  )
  .parentthis.count'i32 = .parentthis.count + 1i
}

list_getAt(index'i32:)'heap class {
  array_getAt(
    parent: .parentthis.data,
    index'i32 : this.index
  )
}

list_setSize(size'i32:)'void {
  array_grow(
    parent: .parentthis.data,
    newSize'i32 : this.newSize
  )
}

global()'void {
  a'stack list_heap_class : list!heap class(this = list!heap class(
    count'i32 = this.count,
    data'stack array_heap_class = this.data
  ))
  for x : 1i to 100000i {
    list_add(
      parent: a,
      item'heap class : this.item
    )
  }
  c'heap class : heap list_getAt(
    parent: a,
    index'i32 : this.index
  )
  x
  void
}

