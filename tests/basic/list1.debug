array!heap class(datasize'i32:, data'ptr:, _isglobal'bool:, count'i32:)'stack array!class {
  --c--
  if (_this->datasize < 0) {
  halt("size is less than zero");
  }
  if (!_this->data) {
  _this->data = malloc(_this->datasize * sizeof(sjs_class*));
  if (!_this->data) {
  halt("grow: out of memory\n");
  }
  }
  --c--
  this
}

array_getat(index'i32:)'heap class {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("getAt: out of bounds\n");
  }
  sjs_class** p = (sjs_class**)_parent->data;
  return;;       
  --c--
}

array_grow(newsize'i32:)'stack array!class {
  newdata'ptr = 0
  --c--
  if (_parent->datasize != newsize) {
  if (newsize < _parent->datasize) {
  halt("grow: new size smaller than old _parent->datasize %d:%d\n", newsize, _parent->datasize);
  }
  sjv_newdata = malloc(newsize * sizeof(sjs_class*));
  if (!_parent->data) {
  halt("grow: out of memory\n");
  }
  sjs_class** p = (sjs_class**)_parent->data;
  sjs_class** newp = (sjs_class**)sjv_newdata;
  int count = _parent->count;
  for (int i = 0; i < count; i++) {
  ;
  }
  }
  --c--
  array!heap class(this = array!heap class(
    datasize'i32 : datasize,
    data'ptr : data,
    _isglobal'bool : _isglobal,
    count'i32 : count
  ))
}

array_initat(index'i32:, item'heap class:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  sjs_class** p = (sjs_class**)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

list!heap class(array'stack array!class=)'stack list!class {
  this
}

list_add(item'heap class:)'void {
  if parent.array.count >= parent.array.datasize {
    parent.array'stack array!class = copy array_grow(
      parent: this,
      newsize'i32 : newsize
    )
    void
  }
  array_initat(
    parent: this,
    index'i32 : index,
    item'heap class : item
  )
}

list_getat(index'i32:)'heap class {
  array_getat(
    parent: this,
    index'i32 : index
  )
}

global()'void {
  import  {
  }
  import  {
  }
  --cdefine--
  void debugout(const char * format, ...);
  void debugoutv(const char * format, va_list args);
  --cdefine--
  --cfunction--
  void debugout(const char * format, ...) {
  va_list args;
  va_start(args, format);
  debugoutv(format, args);
  va_end(args);
  }
  void debugoutv(const char * format, va_list args) {
  #ifdef _WINDOWS
  char text[1024];
  vsnprintf(text, sizeof(text), format, args);
  OutputDebugStringA(text);
  #else
  vfprintf(stderr, format, args);
  #endif
  }
  --cfunction--
  f32_pi'f32 : 3.14159265358979323846ff
  --cdefine--
  void halt(const char * format, ...);
  --cdefine--
  --cfunction--
  void halt(const char * format, ...) {
  va_list args;
  va_start(args, format);
  debugoutv(format, args);
  va_end(args);
  #ifdef _DEBUG
  printf("\npress return to end\n");
  getchar();
  #endif
  exit(-1);
  }
  --cfunction--
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --ctypedef--
  typedef struct td_delete_cb delete_cb;
  typedef struct td_delete_cb_list delete_cb_list;
  --ctypedef--
  --cstruct--
  struct td_delete_cb {
  void* _parent;
  void (*_cb)(void* _parent, void* object);
  };
  struct td_delete_cb_list {
  int size;
  delete_cb cb[5];
  delete_cb_list* next;
  };
  --cstruct--
  --cdefine--
  void ptr_hash(void* p, uint32_t* result);
  void ptr_isequal(void *p1, void* p2, bool* result);
  void delete_cb_list_free(delete_cb_list* d);
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_invoke(delete_cb_list* d, void* p);
  void weakptr_init();
  void weakptr_release(void* v);
  void weakptr_cb_add(void* v, delete_cb cb);
  void weakptr_cb_remove(void* v, delete_cb cb);
  void weakptr_clear(void* parent, void* v);
  void ptr_init();
  void ptr_retain(void* ptr);
  bool ptr_release(void* ptr);
  --cdefine--
  --cfunction--
  void ptr_hash(void* p, uint32_t* result) {
  #ifdef __32__
  *result = kh_int_hash_func((uintptr_t)p);
  #else
  *result = kh_int64_hash_func((uintptr_t)p);
  #endif
  }
  void ptr_isequal(void *p1, void* p2, bool* result) {
  *result = (p1 == p2);
  }
  void delete_cb_list_free(delete_cb_list* d) {
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  free(d);
  }
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb) {
  if (d->size < 5) {
  d->cb[d->size] = cb;
  d->size++;
  }
  else {
  if (!d->next) {
  d->next = (delete_cb_list*)malloc(sizeof(delete_cb_list));
  }
  delete_cb_list_add(d->next, cb);
  }
  }
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb) {
  for (int i = 0; i < d->size; i++) {
  if (d->cb[i]._parent == cb._parent && d->cb[i]._cb == cb._cb) {
  for (int j = i; j < d->size - 1; j++) {
  d->cb[j] = d->cb[j + 1];
  }
  d->size--;
  }
  }
  if (d->next) {
  delete_cb_list_remove(d->next, cb);
  }
  }
  void delete_cb_list_invoke(delete_cb_list* d, void* p) {
  for (int i = 0; i < d->size; i++) {
  d->cb[i]._cb(d->cb[i]._parent, p);
  }
  if (d->next) {
  delete_cb_list_invoke(d->next, p);
  }
  }
  KHASH_INIT_TYPEDEF(weakptr_hashtable_type, void*, delete_cb_list)
  KHASH_INIT_FUNCTION(weakptr_hashtable_type, void*, delete_cb_list, 1, ptr_hash, ptr_isequal)
  khash_t(weakptr_hashtable_type)* weakptr_hashtable;
  void weakptr_init() {
  weakptr_hashtable = kh_init(weakptr_hashtable_type);
  }
  void weakptr_release(void* v) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_invoke(d, v);
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  }
  }
  void weakptr_cb_add(void* v, delete_cb cb) {
  delete_cb_list* d;
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k == kh_end(weakptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(weakptr_hashtable_type, weakptr_hashtable, v, &ret);
  if (!ret) kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  d = &kh_value(weakptr_hashtable, k);
  d->size = 0;
  d->next = 0;
  }
  else {
  d = &kh_value(weakptr_hashtable, k);
  }
  delete_cb_list_add(d, cb);
  }
  void weakptr_cb_remove(void* v, delete_cb cb) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_remove(d, cb);
  }
  }
  KHASH_INIT_TYPEDEF(ptr_hashtable_type, void*, int)
  KHASH_INIT_FUNCTION(ptr_hashtable_type, void*, int, 1, ptr_hash, ptr_isequal)
  khash_t(ptr_hashtable_type)* ptr_hashtable;
  void ptr_init() {
  ptr_hashtable = kh_init(ptr_hashtable_type);
  }
  void ptr_retain(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k == kh_end(ptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(ptr_hashtable_type, ptr_hashtable, v, &ret);
  if (!ret) kh_del(ptr_hashtable_type, ptr_hashtable, k);
  kh_value(ptr_hashtable, k) = 1;
  }
  else {
  kh_value(ptr_hashtable, k)++;
  }
  }
  bool ptr_release(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k != kh_end(ptr_hashtable)) {
  kh_value(ptr_hashtable, k)--;
  if (kh_value(ptr_hashtable, k) == 0) {
  kh_del(ptr_hashtable_type, ptr_hashtable, k);
  }
  return false;
  }
  return true;
  }
  void weakptr_clear(void* parent, void* v) {
  void** p = (void**)parent;
  if (*p != v) {
  halt("weakptr was changed without clearing callback");
  }
  *p = 0;
  }
  --cfunction--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #ifdef __GNUC__
  #if __x86_64__ 
  #define __LINUX__
  #define __64__
  #elif __i386__ 
  #define __LINUX__
  #define __32__
  #else
  #define __LINUX__
  #define __32__
  #endif
  #elif _MSC_VER
  #if _WIN64 
  #define __WINDOWS__
  #define __64__
  #elif _WIN32 
  #define __WINDOWS__
  #define __32__
  #else
  #error "WINDOWS UNSUPPORTED BITS"
  #endif
  #else
  #error "UNKNOWN PLATFORM"
  #endif
  --cinclude--
  --cdefine--
  #include <lib/common/object.h>
  --cdefine--
  --cfunction--
  #include <lib/common/object.c>
  --cfunction--
  a'stack list!class : list!heap class(this = list!heap class(
    array'stack array!class = array
  ))
  for x : 1i to 100000i {
    list_add(
      parent: this,
      item'heap class : item
    )
  }
  c'heap class : list_getat(
    parent: this,
    index'i32 : index
  )
  c.x
  void
}

