array!i32([stack]size'i32=, [stack]data'ptr=, [stack]_isGlobal'bool=) {
  c{

		if (_this->size < 0) {
			exit(-1);
		}

		if (_this->data) {
			_this->_isGlobal = true;
		} else {
			_this->data = (uintptr_t)malloc(_this->size * sizeof(#type(t)));
		}
	
}c
  this
}

array_getAt([heap]index'i32:) c{

		#forceParent()

		if (index >= _parent->size || index < 0) {
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
		#type(t) val = p[index];
		if (!#isValue(t)) {
			if (val == 0) {
				exit(-1);
			}
		}
		return val;		
	
}c

array_setAt([stack]index'i32:, [heap]item'i32:) c{

		#forceParent()
		#forceHeap(item)

		if (index >= _parent->size || index < 0) {
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
		#release(t, p[index]);
		#retain(t, item);
		p[index] = item;
	
}c

global {
  [stack]a'array_i32 : {
    [stack]sjv_array1'array_i32 : [stack]array!i32([stack]this : array!i32(
      [stack]size'i32 = ,
      [stack]data'ptr = 0 as ptr,
      [stack]_isGlobal'bool = false
    ))
    array_setAt([stack]this : array_setAt(
      parent: [stack]sjv_array1,
      [stack]index'i32 : ,
      [heap]item'i32 : 1
    ))
    array_setAt([stack]this : array_setAt(
      parent: [stack]sjv_array1,
      [stack]index'i32 : ,
      [heap]item'i32 : 2
    ))
    array_setAt([stack]this : array_setAt(
      parent: [stack]sjv_array1,
      [stack]index'i32 : ,
      [heap]item'i32 : 3
    ))
    sjv_array1
  }
  array_getAt([stack]this : array_getAt(
    parent: [stack]a,
    [heap]index'i32 : 0
  ))
}

