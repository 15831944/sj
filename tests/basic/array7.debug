array__quicksort(left'i32:, right'i32:)'void {
  i'i32 = left
  j'i32 = right
  pivot'stack class : array_getat(
    parent: this,
    index'i32 : index
  )
  while i <= j{
    while class_isless(
      parent: this,
      c'stack class : c
    ){
      i'i32 = i + 1i
    }
    while class_isgreater(
      parent: this,
      c'stack class : c
    ){
      j'i32 = j - 1i
    }
    if i <= j {
      tmp'stack class : array_getat(
        parent: this,
        index'i32 : index
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      i'i32 = i + 1i
      j'i32 = j - 1i
    }
  }
  if left < j {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
  if i < right {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
}

array__quicksortcallback(left'i32:, right'i32:, cb'local (:stack class, :stack class)i32:)'void {
  i'i32 = left
  j'i32 = right
  pivot'stack class : array_getat(
    parent: this,
    index'i32 : index
  )
  while i <= j{
    while cb(
      param0'stack class : param0,
      param1'stack class : param1
    ) < 0i{
      i'i32 = i + 1i
    }
    while cb(
      param0'stack class : param0,
      param1'stack class : param1
    ) > 0i{
      j'i32 = j - 1i
    }
    if i <= j {
      tmp'stack class : array_getat(
        parent: this,
        index'i32 : index
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      i'i32 = i + 1i
      j'i32 = j - 1i
    }
  }
  if left < j {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
  if i < right {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
}

array_getat(index'i32:)'stack class {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("getAt: out of bounds\n");
  }
  sjs_class* p = (sjs_class*)_parent->data;
  return;;       
  --c--
}

array_initat(index'i32:, item'stack class:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  sjs_class* p = (sjs_class*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

array_reverse()'void {
  for i : 0i to parent.count / 2i {
    j'i32 : parent.count - i - 1i
    tmp'stack class : array_getat(
      parent: this,
      index'i32 : index
    )
    array_setat(
      parent: this,
      index'i32 : index,
      item'stack class : item
    )
    array_setat(
      parent: this,
      index'i32 : index,
      item'stack class : item
    )
  }
}

array_setat(index'i32:, item'stack class:)'void {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("setAt: out of bounds %d:%d\n", index, _parent->count);
  }
  sjs_class* p = (sjs_class*)_parent->data;
  ;
  ;
  --c--
}

array_sort()'void {
  if parent.count > 1i {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
}

array_sortcb(cb'local (:stack class, :stack class)i32:)'void {
  if parent.count > 1i {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
}





class_isgreater(c'stack class:)'bool {
  parent.x > c.x
}

class_isless(c'stack class:)'bool {
  parent.x < c.x
}

writeline(data'stack string:)'void {
  --c--
  printf("%s\n", (char*)data->data.data);
  --c--
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  --cdefine--
  void halt(const char * format, ...);
  --cdefine--
  --cfunction--
  void halt(const char * format, ...) {
  va_list args;
  va_start(args, format);
  vprintf(format, args);
  va_end(args);
  #ifdef _DEBUG
  printf("\npress return to end\n");
  getchar();
  #endif
  exit(-1);
  }
  --cfunction--
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --ctypedef--
  typedef struct td_delete_cb delete_cb;
  typedef struct td_delete_cb_list delete_cb_list;
  --ctypedef--
  --cstruct--
  struct td_delete_cb {
  void* _parent;
  void (*_cb)(void* _parent, void* object);
  };
  struct td_delete_cb_list {
  int size;
  delete_cb cb[5];
  delete_cb_list* next;
  };
  --cstruct--
  --cdefine--
  void ptr_hash(void* p, uint32_t* result);
  void ptr_isequal(void *p1, void* p2, bool* result);
  void delete_cb_list_free(delete_cb_list* d);
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_invoke(delete_cb_list* d, void* p);
  void weakptr_init();
  void weakptr_release(void* v);
  void weakptr_cb_add(void* v, delete_cb cb);
  void weakptr_cb_remove(void* v, delete_cb cb);
  void weakptr_clear(void* parent, void* v);
  void ptr_init();
  void ptr_retain(void* ptr);
  bool ptr_release(void* ptr);
  --cdefine--
  --cfunction--
  void ptr_hash(void* p, uint32_t* result) {
  #ifdef __32__
  *result = kh_int_hash_func((uintptr_t)p);
  #else
  *result = kh_int64_hash_func((uintptr_t)p);
  #endif
  }
  void ptr_isequal(void *p1, void* p2, bool* result) {
  *result = (p1 == p2);
  }
  void delete_cb_list_free(delete_cb_list* d) {
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  free(d);
  }
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb) {
  if (d->size < 5) {
  d->cb[d->size] = cb;
  d->size++;
  }
  else {
  if (!d->next) {
  d->next = (delete_cb_list*)malloc(sizeof(delete_cb_list));
  }
  delete_cb_list_add(d->next, cb);
  }
  }
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb) {
  for (int i = 0; i < d->size; i++) {
  if (d->cb[i]._parent == cb._parent && d->cb[i]._cb == cb._cb) {
  for (int j = i; j < d->size - 1; j++) {
  d->cb[j] = d->cb[j + 1];
  }
  d->size--;
  }
  }
  if (d->next) {
  delete_cb_list_remove(d->next, cb);
  }
  }
  void delete_cb_list_invoke(delete_cb_list* d, void* p) {
  for (int i = 0; i < d->size; i++) {
  d->cb[i]._cb(d->cb[i]._parent, p);
  }
  if (d->next) {
  delete_cb_list_invoke(d->next, p);
  }
  }
  KHASH_INIT_TYPEDEF(weakptr_hashtable_type, void*, delete_cb_list)
  KHASH_INIT_FUNCTION(weakptr_hashtable_type, void*, delete_cb_list, 1, ptr_hash, ptr_isequal)
  khash_t(weakptr_hashtable_type)* weakptr_hashtable;
  void weakptr_init() {
  weakptr_hashtable = kh_init(weakptr_hashtable_type);
  }
  void weakptr_release(void* v) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_invoke(d, v);
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  }
  }
  void weakptr_cb_add(void* v, delete_cb cb) {
  delete_cb_list* d;
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k == kh_end(weakptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(weakptr_hashtable_type, weakptr_hashtable, v, &ret);
  if (!ret) kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  d = &kh_value(weakptr_hashtable, k);
  d->size = 0;
  d->next = 0;
  }
  else {
  d = &kh_value(weakptr_hashtable, k);
  }
  delete_cb_list_add(d, cb);
  }
  void weakptr_cb_remove(void* v, delete_cb cb) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_remove(d, cb);
  }
  }
  KHASH_INIT_TYPEDEF(ptr_hashtable_type, void*, int)
  KHASH_INIT_FUNCTION(ptr_hashtable_type, void*, int, 1, ptr_hash, ptr_isequal)
  khash_t(ptr_hashtable_type)* ptr_hashtable;
  void ptr_init() {
  ptr_hashtable = kh_init(ptr_hashtable_type);
  }
  void ptr_retain(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k == kh_end(ptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(ptr_hashtable_type, ptr_hashtable, v, &ret);
  if (!ret) kh_del(ptr_hashtable_type, ptr_hashtable, k);
  kh_value(ptr_hashtable, k) = 1;
  }
  else {
  kh_value(ptr_hashtable, k)++;
  }
  }
  bool ptr_release(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k != kh_end(ptr_hashtable)) {
  kh_value(ptr_hashtable, k)--;
  if (kh_value(ptr_hashtable, k) == 0) {
  kh_del(ptr_hashtable_type, ptr_hashtable, k);
  }
  return false;
  }
  return true;
  }
  void weakptr_clear(void* parent, void* v) {
  void** p = (void**)parent;
  if (*p != v) {
  halt("weakptr was changed without clearing callback");
  }
  *p = 0;
  }
  --cfunction--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #ifdef __GNUC__
  #if __x86_64__ 
  #define __LINUX__
  #define __64__
  #elif __i386__ 
  #define __LINUX__
  #define __32__
  #else
  Invalid bits
  #endif
  #elif _MSC_VER
  #if _WIN64 
  #define __WINDOWS__
  #define __64__
  #elif _WIN32 
  #define __WINDOWS__
  #define __32__
  #else
  Invalid bits
  #endif
  #else
  Invalid compiler
  #endif
  --cinclude--
  a'stack array!class : [array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  )]
  array_sort(
    parent: this
  )
  writeline(
    data'stack string : data
  )
  array_reverse(
    parent: this
  )
  writeline(
    data'stack string : data
  )
  array_sortcb(
    parent: this,
    cb'local (:stack class, :stack class)i32 : cb
  )
  writeline(
    data'stack string : data
  )
  void
}

