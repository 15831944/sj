array__quicksort(left'i32:, right'i32:)'void {
  i'i32 = left
  j'i32 = right
  pivot'stack class : array_getat(
    parent: this,
    index'i32 : index
  )
  while i <= j{
    while class_isless(
      parent: this,
      c'stack class : c
    ){
      i'i32 = i + 1i
    }
    while class_isgreater(
      parent: this,
      c'stack class : c
    ){
      j'i32 = j - 1i
    }
    if i <= j {
      tmp'stack class : array_getat(
        parent: this,
        index'i32 : index
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      i'i32 = i + 1i
      j'i32 = j - 1i
    }
  }
  if left < j {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
  if i < right {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
}

array__quicksortcallback(left'i32:, right'i32:, cb'local (:stack class, :stack class)i32:)'void {
  i'i32 = left
  j'i32 = right
  pivot'stack class : array_getat(
    parent: this,
    index'i32 : index
  )
  while i <= j{
    continue'bool = true
    while i < parent.count && continue{
      continue'bool = cb(
        param0'stack class : param0,
        param1'stack class : param1
      ) < 0i
      if continue {
        i'i32 = i + 1i
      }
    }
    continue'bool = true
    while j >= 0i && continue{
      continue'bool = cb(
        param0'stack class : param0,
        param1'stack class : param1
      ) > 0i
      if continue {
        j'i32 = j - 1i
      }
    }
    if i <= j {
      tmp'stack class : array_getat(
        parent: this,
        index'i32 : index
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      array_setat(
        parent: this,
        index'i32 : index,
        item'stack class : item
      )
      i'i32 = i + 1i
      j'i32 = j - 1i
    }
  }
  if left < j {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
  if i < right {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
}

array_getat(index'i32:)'stack class {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("getAt: out of bounds\n");
  }
  sjs_class* p = (sjs_class*)_parent->data;
  return;;       
  --c--
}

array_initat(index'i32:, item'stack class:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  sjs_class* p = (sjs_class*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

array_reverse()'void {
  for i : 0i to parent.count / 2i {
    j'i32 : parent.count - i - 1i
    tmp'stack class : array_getat(
      parent: this,
      index'i32 : index
    )
    array_setat(
      parent: this,
      index'i32 : index,
      item'stack class : item
    )
    array_setat(
      parent: this,
      index'i32 : index,
      item'stack class : item
    )
  }
}

array_setat(index'i32:, item'stack class:)'void {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("setAt: out of bounds %d:%d\n", index, _parent->count);
  }
  sjs_class* p = (sjs_class*)_parent->data;
  ;
  ;
  --c--
}

array_sort()'void {
  if parent.count > 1i {
    array__quicksort(
      parent: this,
      left'i32 : left,
      right'i32 : right
    )
  }
}

array_sortcb(cb'local (:stack class, :stack class)i32:)'void {
  if parent.count > 1i {
    array__quicksortcallback(
      parent: this,
      left'i32 : left,
      right'i32 : right,
      cb'local (:stack class, :stack class)i32 : cb
    )
  }
}





class_isgreater(c'stack class:)'bool {
  parent.x > c.x
}

class_isless(c'stack class:)'bool {
  parent.x < c.x
}

log(minlevel'loglevel=)'stack log {
  this
}

writeline(data'stack string:)'void {
  --c--
  printf("%s\n", (char*)data->data.data);
  --c--
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  a'stack array!class : [array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'stack class : item
  )]
  array_sort(
    parent: this
  )
  writeline(
    data'stack string : data
  )
  array_reverse(
    parent: this
  )
  writeline(
    data'stack string : data
  )
  array_sortcb(
    parent: this,
    cb'local (:stack class, :stack class)i32 : cb
  )
  writeline(
    data'stack string : data
  )
  void
}

