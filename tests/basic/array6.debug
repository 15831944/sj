array!f32(datasize'i32:, data'ptr:, isglobal'bool:, count'i32:)'stack array!f32 {
  --c--
  if (_this->datasize < 0) {
  halt("size is less than zero");
  }
  if (!_this->data) {
  _this->data = (int*)malloc(_this->datasize * sizeof(float) + sizeof(int)) + 1;
  int* refcount = (int*)_this->data - 1;
  *refcount = 1;
  if (!_this->data) {
  halt("grow: out of memory\n");
  }
  }
  --c--
  this
}

array_filter(cb'local (:f32)bool:)'stack array!f32 {
  newdata'ptr = 0
  newcount'i32 = 0i
  --c--
  sjv_newdata = (int*)malloc(_parent->count * sizeof(float) + sizeof(int)) + 1;
  int* refcount = (int*)sjv_newdata - 1;
  *refcount = 1;
  --c--
  for i : 0i to parent.count {
    item'f32 : array_getat(
      parent: this,
      index'i32 : index
    )
    if cb(
      param0'f32 : param0
    ) {
      --c--
      float* p = (float*)sjv_newdata;
      ;
      --c--
      newcount'i32 = newcount + 1i
    }
  }
  array!f32(this = array!f32(
    datasize'i32 : datasize,
    data'ptr : data,
    isglobal'bool : isglobal,
    count'i32 : count
  ))
}

array_foldl!stack sum(initial'stack sum:, cb'local (:stack sum, :f32)stack sum:)'stack sum {
  r'local sum = initial
  for i : 0i to parent.count {
    r'local sum = cb(
      param0'stack sum : param0,
      param1'f32 : param1
    )
  }
  copy r
}

array_getat(index'i32:)'f32 {
  --c--
  if (index >= _parent->count || index < 0) {
  halt("getAt: out of bounds\n");
  }
  float* p = (float*)_parent->data;
  return;;       
  --c--
}

array_initat(index'i32:, item'i32:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  int32_t* p = (int32_t*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

array_map!f32(cb'local (:i32)f32:)'stack array!f32 {
  newdata'ptr = 0
  --c--
  sjv_newdata = (int*)malloc(_parent->count * sizeof(float) + sizeof(int)) + 1;
  int* refcount = (int*)sjv_newdata - 1;
  *refcount = 1;
  --c--
  for i : 0i to parent.count {
    newitem'f32 : cb(
      param0'i32 : param0
    )
    --c--
    float* p = (float*)sjv_newdata;
    ;
    --c--
  }
  array!f32(this = array!f32(
    datasize'i32 : datasize,
    data'ptr : data,
    isglobal'bool : isglobal,
    count'i32 : count
  ))
}







log(minlevel'loglevel=)'stack log {
  this
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  clocks_per_sec'i32 = 0i
  --c--
  sjv_clocks_per_sec = CLOCKS_PER_SEC;
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  a'stack array!i32 : [array_initat(
    parent: this,
    index'i32 : index,
    item'i32 : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'i32 : item
  ), array_initat(
    parent: this,
    index'i32 : index,
    item'i32 : item
  )]
  b'stack array!f32 : array_map!f32(
    parent: this,
    cb'local (:i32)f32 : cb
  )
  c'stack array!f32 : array_filter(
    parent: this,
    cb'local (:f32)bool : cb
  )
  d'stack sum : array_foldl!stack sum(
    parent: this,
    initial'stack sum : initial,
    cb'local (:stack sum, :f32)stack sum : cb
  )
  void
}

