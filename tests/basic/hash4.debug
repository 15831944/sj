hash![heap #interface, i32]()'stack hash![#interface, i32] {
  --cdefine--
  #ifndef heap_iface_interface_i32_hash_typedef
  #define heap_iface_interface_i32_hash_typedef
  KHASH_INIT_TYPEDEF(heap_iface_interface_i32_hash_type, sji_interface, int32_t)
  #endif
  --cdefine--
  --cfunction--
  #ifndef heap_iface_interface_i32_hash_function
  #define heap_iface_interface_i32_hash_function
  #if false
  KHASH_INIT_FUNCTION_DEREF(heap_iface_interface_i32_hash_type, sji_interface, int32_t, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(heap_iface_interface_i32_hash_type, sji_interface, int32_t, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(heap_iface_interface_i32_hash_type);
  --c--
  this
}

hash_each(cb'local (:heap #interface, :i32)void:)'void {
  --c--
  khash_t(heap_iface_interface_i32_hash_type)* p = (khash_t(heap_iface_interface_i32_hash_type)*)_parent->_hash;
  for (khiter_t k = kh_begin(p); k != kh_end(p); ++k) {
  if (kh_exist(p, k)) {
  cb._cb(
  cb._parent, 
  #if false
  &kh_key(p, k), 
  #else
  kh_key(p, k), 
  #endif
  #if false
  &kh_value(p, k)
  #else
  kh_value(p, k)
  #endif
  );
  }
  }
  --c--
}

hash_getat(key'heap #interface:)'i32? {
  --c--
  khash_t(heap_iface_interface_i32_hash_type)* p = (khash_t(heap_iface_interface_i32_hash_type)*)_parent->_hash;
  #if false
  khiter_t k = kh_get(heap_iface_interface_i32_hash_type, p, *key);
  #else
  khiter_t k = kh_get(heap_iface_interface_i32_hash_type, p, key);
  #endif
  if (k == kh_end(p)) {
  return;
  }
  return;;
  --c--
}

hash_setat(key'heap #interface:, val'i32:)'void {
  --c--
  khash_t(heap_iface_interface_i32_hash_type)* p = (khash_t(heap_iface_interface_i32_hash_type)*)_parent->_hash;
  #if false
  khiter_t k = kh_get(heap_iface_interface_i32_hash_type, p, *key);
  #else
  khiter_t k = kh_get(heap_iface_interface_i32_hash_type, p, key);
  #endif
  if (k != kh_end(p)) {            
  ;
  }
  int ret;
  #if false
  k = kh_put(heap_iface_interface_i32_hash_type, _parent->_hash, *key, &ret);
  #else
  k = kh_put(heap_iface_interface_i32_hash_type, _parent->_hash, key, &ret);
  #endif
  if (!ret) kh_del(heap_iface_interface_i32_hash_type, p, k);
  #if false
  delete_cb cb = { _parent, (void(*)(void*, void*))INVALID };
  weakptr_cb_add(key._parent, cb);
  #else
  sji_interface t;
  ;
  #endif
  #if false
  delete_cb cb = { _parent, (void(*)(void*, void*))INVALID };
  weakptr_cb_add(val, cb);
  kh_val(p, k) = val;
  #else
  ;
  #endif
  --c--
}

log(minlevel'loglevel=)'stack log {
  this
}

writeline(data'stack string:)'void {
  --c--
  debugout("%s\n", (char*)data->data.data);
  --c--
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  a'stack hash![#interface, i32] : hash![heap #interface, i32](this = hash![heap #interface, i32]())
  hash_setat(
    parent: this,
    key'heap #interface : key,
    val'i32 : val
  )
  b'i32? : hash_getat(
    parent: this,
    key'heap #interface : key
  )
  hash_each(
    parent: this,
    cb'local (:heap #interface, :i32)void : cb
  )
  writeline(
    data'stack string : data
  )
  void
}

