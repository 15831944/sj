array!char(datasize'i32:, data'ptr:, isglobal'bool:, count'i32:)'stack array!char {
  --c--
  if (_this->datasize < 0) {
  halt("size is less than zero");
  }
  if (!_this->data) {
  _this->data = (int*)malloc(_this->datasize * sizeof(char) + sizeof(int)) + 1;
  int* refcount = (int*)_this->data - 1;
  *refcount = 1;
  if (!_this->data) {
  halt("grow: out of memory\n");
  }
  }
  --c--
  this
}

array_grow(newsize'i32:)'stack array!char {
  newdata'ptr = 0
  --c--
  if (_parent->datasize != newsize) {
  if (newsize < _parent->datasize) {
  halt("grow: new size smaller than old _parent->datasize %d:%d\n", newsize, _parent->datasize);
  }
  sjv_newdata = (int*)(malloc(sizeof(int) + newsize * sizeof(char))) + 1;
  int* refcount = (int*)sjv_newdata - 1;
  *refcount = 1;
  if (!_parent->data) {
  halt("grow: out of memory\n");
  }
  char* p = (char*)_parent->data;
  char* newp = (char*)sjv_newdata;
  int count = _parent->count;
  #if true
  memcpy(newp, p, sizeof(char) * count);
  #else
  for (int i = 0; i < count; i++) {
  ;
  }
  #endif
  }
  --c--
  array!char(this = array!char(
    datasize'i32 : datasize,
    data'ptr : data,
    isglobal'bool : isglobal,
    count'i32 : count
  ))
}

array_initat(index'i32:, item'char:)'void {
  --c--
  if (index != _parent->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= _parent->datasize || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, _parent->datasize);
  }
  char* p = (char*)_parent->data;
  ;
  _parent->count = index + 1;
  --c--
}

clock()'i64 {
  --c--
  return;;
  --c--
}

f64_pow(x'f64:, y'f64:)'f64 {
  --c--
  return;;
  --c--
}

f64_sqrt(v'f64:)'f64 {
  --c--
  return;;
  --c--
}

i32_asstring(val'i32:, base'i32:)'stack string {
  count'i32 = 0i
  data'ptr = 0
  --c--
  sjv_data = (int*)malloc(sizeof(int) + sizeof(char) * 256) + 1;
  int* refcount = (int*)sjv_data - 1;
  *refcount = 1;
  char *tmp = (char*)sjv_data + 128;
  char *tp = (char*)sjv_data + 128;
  int i;
  unsigned v;
  int sign = (base == 10 && val < 0);    
  if (sign)
  v = -val;
  else
  v = (unsigned)val;
  while (v || tp == tmp)
  {
  i = v % base;
  v /= base; // v/=base uses less CPU clocks than v=v/base does
  if (i < 10)
  *tp++ = i + '0';
  else
  *tp++ = i + 'a' - 10;
  }
  int len = tp - tmp;
  char* sp = (char*)sjv_data;
  if (sign) 
  {
  *sp++ = '-';
  len++;
  }
  while (tp > tmp)
  *sp++ = *--tp;
  sjv_count = len;
  --c--
  string(this = string(
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
}

log(minlevel'loglevel=)'stack log {
  this
}

string(count'i32=, data'stack array!char=, _isnullterminated'bool=)'stack string {
  this
}

string_add(item'stack string:)'stack string {
  if item.count == 0i {
    string(this = string(
      count'i32 = count,
      data'stack array!char = data,
      _isnullterminated'bool = _isnullterminated
    ))
  } else {
    newdata'stack array!char : if parent.count + item.count > parent.data.datasize {
      array_grow(
        parent: this,
        newsize'i32 : newsize
      )
    } else {
      copy parent.data
    }
    newcount'i32 = parent.count
    for i : 0i to item.count {
      array_initat(
        parent: this,
        index'i32 : index,
        item'char : item
      )
      newcount'i32 = newcount + 1i
    }
    string(this = string(
      count'i32 = count,
      data'stack array!char = data,
      _isnullterminated'bool = _isnullterminated
    ))
  }
}

string_nullterminate()'void {
  if !parent.data.isglobal || !parent._isnullterminated {
    if parent.count + 1i > parent.data.datasize {
      parent.data'stack array!char = copy array_grow(
        parent: this,
        newsize'i32 : newsize
      )
    }
    array_initat(
      parent: this,
      index'i32 : index,
      item'char : item
    )
    parent._isnullterminated'bool = true
  }
  void
}

string_touppercase()'stack string {
  a'stack array!char : array!char(this = array!char(
    datasize'i32 : datasize,
    data'ptr : data,
    isglobal'bool : isglobal,
    count'i32 : count
  ))
  for i : 0i to parent.count {
    array_initat(
      parent: this,
      index'i32 : index,
      item'char : item
    )
  }
  string(this = string(
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
}

writeline(data'stack string:)'void {
  string_nullterminate(
    parent: this
  )
  --c--
  debugout("%s\n", (char*)data->data.data);
  --c--
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel
  ))
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  clocks_per_sec'i32 = 0i
  --c--
  sjv_clocks_per_sec = CLOCKS_PER_SEC;
  --c--
  --cinclude--
  #include <lib/common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/common/common.c>
  --cfunction--
  start'i64 : clock()
  str'stack string = string(this = string(
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
  for i : 0i to 50000000i {
    f64_sqrt(
      v'f64 : v
    )
    f64_pow(
      x'f64 : x,
      y'f64 : y
    )
    j'i32 : i * 745i
    s1'stack string : i32_asstring(
      val'i32 : val,
      base'i32 : base
    )
    s2'stack string : string_add(
      parent: this,
      item'stack string : item
    )
    s3'stack string : string_touppercase(
      parent: this
    )
    if i %% 300i == 0i {
      str'stack string = copy string(this = string(
        count'i32 = count,
        data'stack array!char = data,
        _isnullterminated'bool = _isnullterminated
      ))
    } else {
      str'stack string = copy string_add(
        parent: this,
        item'stack string : item
      )
    }
  }
  end'i64 : clock()
  writeline(
    data'stack string : data
  )
  void
}

