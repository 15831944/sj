anon1()'anon1 {
  this
}

anon1_write([heap]data'string:)'void {
  c{

			#include(<stdio.h>)
			#forceParent()
			printf("%s\n", (char*)data->data->data);
		
}c
}

anon2()'anon2 {
  this
}

anon3()'anon3 {
  this
}

anon4()'anon4 {
  this
}

anon4_i32toString([stack]val'i32:)'string {
  [heap]count'i32 = 0i
  [heap]data'ptr = 0i as ptr
  c{

			char buf[32] = { 0 };
			int i = 30;	
			do {
				buf[i] = "0123456789"[val % 10];	
				i--;
				val /= 10;
			} while (val && i);
			count = 30 - i;
			data = (uintptr_t)malloc(sizeof(char) * (count + 1));
			memcpy((void*)data, &buf[i+1], count + 1);
		
}c
  [heap]string([heap]this : string(
    parent: [stack]this,
    [heap]count'i32 = count,
    [heap]data'array_char = [heap]array!char([heap]this : array!char(
      [heap]size'i32 = count + 1i,
      [heap]data'ptr = data,
      [heap]_isGlobal'bool = false
    ))
  ))
}

array!#element([stack]size'i32=, [stack]data'ptr=, [stack]_isGlobal'bool=)'array_#element {
  c{

		if (_this->size < 0) {
			exit(-1);
		}

		if (_this->data) {
			_this->_isGlobal = true;
		} else {
			_this->data = (uintptr_t)calloc(_this->size * sizeof(#type(t)), 1);
			if (!_this->data) {
				printf("grow: out of memory\n");
				exit(-1);				
			}
		}
	
}c
  this
}

array!char([heap]size'i32=, [heap]data'ptr=, [heap]_isGlobal'bool=)'array_char {
  c{

		if (_this->size < 0) {
			exit(-1);
		}

		if (_this->data) {
			_this->_isGlobal = true;
		} else {
			_this->data = (uintptr_t)calloc(_this->size * sizeof(#type(t)), 1);
			if (!_this->data) {
				printf("grow: out of memory\n");
				exit(-1);				
			}
		}
	
}c
  this
}

array_getAt([heap]index'i32:)'char c{

		#forceParent()

		if (index >= _parent->size || index < 0) {
			printf("getAt: out of bounds\n");
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
		#type(t) val = p[index];
##if !#isValue(t)
		if (val == 0) {
			printf("getAt: value is not defined at %d\n", index);
			exit(-1);
		}
##endif
		*_return = val;		
	
}c

array_getAt([stack]index'i32:)'#element c{

		#forceParent()

		if (index >= _parent->size || index < 0) {
			printf("getAt: out of bounds\n");
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
		#type(t) val = p[index];
##if !#isValue(t)
		if (val == 0) {
			printf("getAt: value is not defined at %d\n", index);
			exit(-1);
		}
##endif
		*_return = val;		
	
}c

array_grow([stack]newSize'i32:)'array_char c{

		#forceParent()
		#include(<string.h>)

		if (_parent->size != newSize) {
			if (newSize < _parent->size) {
				printf("grow: new size smaller than old size %d:%d\n", newSize, _parent->size);
				exit(-1);
			}
			
			if (_parent->_isGlobal) {
				_parent->_isGlobal = false;
				#type(t)* p = (#type(t)*)_parent->data;
				_parent->data = (uintptr_t)calloc(newSize * sizeof(#type(t)), 1);
				if (!_parent->data) {
					printf("grow: out of memory\n");
					exit(-1);				
				}
				memcpy((void*)_parent->data, p, _parent->size * sizeof(#type(t)));
			} else {
				_parent->data = (uintptr_t)realloc((void*)_parent->data, newSize * sizeof(#type(t)));
				if (!_parent->data) {
					printf("grow: out of memory\n");
					exit(-1);				
				}
				memset((void*)_parent->data + _parent->size, 0, newSize - _parent->size);
			}
			_parent->size = newSize;
		}

		*_return = _parent;
	
}c

array_setAt([stack]index'i32:, [heap]item'#element:)'void c{

		#forceParent()
		#forceHeap(item)

		if (index >= _parent->size || index < 0) {
			printf("setAt: out of bounds %d:%d\n", index, _parent->size);
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
##if !#isValue(t)
		if (p[index] != 0) {
			#release(t, p[index]);
		}
##endif
		#retain(t, item);
		p[index] = item;
	
}c

array_setAt([stack]index'i32:, [heap]item'char:)'void c{

		#forceParent()
		#forceHeap(item)

		if (index >= _parent->size || index < 0) {
			printf("setAt: out of bounds %d:%d\n", index, _parent->size);
			exit(-1);
		}

		#type(t)* p = (#type(t)*)_parent->data;
##if !#isValue(t)
		if (p[index] != 0) {
			#release(t, p[index]);
		}
##endif
		#retain(t, item);
		p[index] = item;
	
}c

element ##element ([stack]id'string:, [stack]children'array_#element:)'element {
  this
}

element_toHTML()'string {
  {
    [heap]string([heap]this : string(
      parent: this,
      [heap]count'i32 = i,
      [heap]data'array_char = [heap]array!char([heap]this : array!char(
        [heap]size'i32 = i,
        [heap]data'ptr = ,
        [heap]_isGlobal'bool = false
      ))
    ))
  }
}

element_update()'void {
  [heap]html'string : {
    [heap]string([heap]this : string(
      parent: [stack]this,
      [heap]count'i32 = i,
      [heap]data'array_char = [heap]array!char([heap]this : array!char(
        [heap]size'i32 = i,
        [heap]data'ptr = ,
        [heap]_isGlobal'bool = false
      ))
    ))
  }
  for i : 0i to this.size {
    [stack]child'#element : [stack]array_getAt([stack]this : array_getAt(
      parent: [stack].parentthis.children,
      [stack]index'i32 : i
    ))
    [heap]string_add([stack]this : string_add(
      parent: [heap]html,
      [stack]item'string : [heap]toHTML(
        parent: [stack]child
      )
    ))
  }
  [heap]anon1_write([stack]this : anon1_write(
    parent: [heap].parent.parentthis.console,
    [heap]data'string : html
  ))
}

string([heap]count'i32=, [heap]data'array_char=)'string {
  this
}

string_add([stack]item'string:)'string {
  if this.count > 0i {
    if .parentthis.count + this.count + 1i > this.size {
      [stack]array_grow([stack]this : array_grow(
        parent: [heap].parentthis.data,
        [stack]newSize'i32 : .parentthis.count + this.count + 1i
      ))
      void
    }
    for i : 0i to this.count {
      [stack]array_setAt([stack]this : array_setAt(
        parent: [heap].parentthis.data,
        [stack]index'i32 : .parentthis.count,
        [heap]item'char : [heap]string_getAt([stack]this : string_getAt(
          parent: [stack]this.item,
          [heap]index'i32 : i
        ))
      ))
      .parentthis.count++
    }
    [stack]array_setAt([stack]this : array_setAt(
      parent: [heap].parentthis.data,
      [stack]index'i32 : .parentthis.count,
      [heap]item'char : 0i as char
    ))
    void
  }
  this
}

string_getAt([heap]index'i32:)'char {
  [heap]array_getAt([stack]this : array_getAt(
    parent: [heap].parentthis.data,
    [heap]index'i32 : this.index
  ))
}

timerElement ##element ([stack]counter'i32=)'timerElement {
  this
}

timerElement_toHTML()'string {
  [heap]a'string : [heap]anon4_i32toString([stack]this : anon4_i32toString(
    parent: [heap].parent.parentthis.convert,
    [stack]val'i32 : .parentthis.counter
  ))
  [heap]b'string : {
    [heap]string([heap]this : string(
      parent: this,
      [heap]count'i32 = i,
      [heap]data'array_char = [heap]array!char([heap]this : array!char(
        [heap]size'i32 = i,
        [heap]data'ptr = ,
        [heap]_isGlobal'bool = false
      ))
    ))
  }
  [heap]string_add([stack]this : string_add(
    parent: [heap]b,
    [stack]item'string : a
  ))
}

toHTML()

global()'void {
  [heap]convert'anon4 : [heap]anon4([heap]this : anon4(
    parent: [stack]this
  ))
  [stack]random'anon3 : [stack]anon3([stack]this : anon3())
  [stack]parse'anon2 : [stack]anon2([stack]this : anon2())
  [heap]console'anon1 : [heap]anon1([heap]this : anon1())
  #element(
    toHTML()'string
  )
  [stack]rootElement'element : [stack]element([stack]this : element(
    parent: [stack]this,
    [stack]id'string : {
      [heap]string([heap]this : string(
        parent: [stack]this,
        [heap]count'i32 = i,
        [heap]data'array_char = [heap]array!char([heap]this : array!char(
          [heap]size'i32 = i,
          [heap]data'ptr = ,
          [heap]_isGlobal'bool = false
        ))
      ))
    },
    [stack]children'array_#element : {
      [stack]sjv_array1'array_#element : [stack]array!#element([stack]this : array!#element(
        [stack]size'i32 = i,
        [stack]data'ptr = 0i as ptr,
        [stack]_isGlobal'bool = false
      ))
      [stack]array_setAt([stack]this : array_setAt(
        parent: [stack]sjv_array1,
        [stack]index'i32 : i,
        [heap]item'#element : [stack]timerElement([stack]this : timerElement(
          parent: [stack]this,
          [stack]counter'i32 = 0i
        )) as #element
      ))
      sjv_array1
    }
  ))
  [heap]element_update([stack]this : element_update(
    parent: [stack]rootElement
  ))
  void
}

