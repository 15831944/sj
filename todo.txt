    if (!returnValue)
        return;

    auto leftType = getType(compiler, result);
    auto rightType = returnValue->type;
    if (!CType::isSameExceptMode(leftType, rightType)) {
        result.addError(loc, CErrorCode::TypeMismatch, "right type '%s' does not match left type '%s'", rightType->name.c_str(), leftType->name.c_str());
        return;
    }

    if (leftType->typeMode != CTM_Local && leftType->typeMode != rightType->typeMode && op != ASSIGN_MutableCopy && op != ASSIGN_ImmutableCopy) {
        result.addError(loc, CErrorCode::TypeMismatch, "right type '%s' cannot change mode to left type '%s' without using a :copy or =copy assignment", rightType->name.c_str(), leftType->name.c_str());
        return;
    }


        if (leftVar->scope.lock() != rightVar->scope.lock() && leftType->typeMode == CTM_Stack && leftStoreValue->type->typeMode == CTM_Stack && op != ASSIGN_MutableCopy && op != ASSIGN_ImmutableCopy) {
        result.addError(loc, CErrorCode::TypeMismatch, "must use a :copy or =copy assignment when changing scope of a stack variable", leftStoreValue->type->name.c_str(), leftType->name.c_str());
        return;
    }


* heap10
* fix string add
* make string immutable
* string not depend on array
* stringBuilder.append
* stringBuilder.toString

* draw box using sdl on windows

* buttonElement
* textElement
* two buttons for +/-

-- features --
* override interfaces : a as type   -> a.asType()'t
* lambda

-- lambda --
array!item(
	each(lambda : '(item)void) {
		for i : 0 to size {
			lambda(getAt(i))
		}
	}
)

arr : [1, 2, 3]
total = 0
arr.each((i:'i32) {
	total += i
	void
})

// definition
struct sjl_anon1 {
	int _refCount
	sjs_object* _parent;
	void (*lambda)(sjs_object*, int32_t)
}

void sjl_anon1_destroy(sjl_anon1 *_this) {
	_this->_parent->_refCount--;
}

// invoke
void array_each() {
	item = array_getAt();
	lambda->lambda(lambda->_parent, item);
}

// create
void sjf_anon2(sjs_func* _parent, int32_t i) {
	_parent->total += i;
}

x = new sjl_anon1
x->_refCount = 1;
x->_parent = _this;
x->_parent->_refCount++;
x->lambda = sjf_anon2;
array_each(arr, x);



func()'auto {
    _this // okay
}

func()'auto {
    class() // okay
}

func()'auto {
    value(class()) // fail, auto is not compatible with option
}

func()'auto {
    a.getAt(0) // fail
}

func(
    c: class()
)'auto {
    c // fail only heap allowed
}

func(
    c'stack : class()
) {
    c // fail cannot return stack class var
}

a : func()	// return stack
func()		// return stack

class(
	a : func()	// return stack if class is stack, help if class is heap
	a = func()	// return heap always
)
