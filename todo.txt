-- features --
* interface
* operators
* array assignment
* lambda

-- interface --
* cast from interface to another interface
* call interace method

void* foo_asInterface(sjs_object* _parent, int sji_foo_id) {
	switch (sji_foo_id) {
	case sji_foo_id:
		return foo_asFoo(_parent);
	}
	return nullptr;
}

-- operators --
	a.x = y 	-> setX(y)
	a as type	-> a.asType()'t

-- array assignment --
* special array assign operation
	func() { [1, 2] }
	[a:, b=] func()
	a : t.getAt(0)
	b = t.getAt(1)

-- lambda --
array!item(
	each(lambda : '(item)void) {
		for i : 0 to size {
			lambda(getAt(i))
		}
	}
)

arr : [1, 2, 3]
total = 0
arr.each((i:'i32) {
	total += i
	void
})

// definition
struct sjl_anon1 {
	int _refCount
	sjs_object* _parent;
	void (*lambda)(sjs_object*, int32_t)
}

void sjl_anon1_destroy(sjl_anon1 *_this) {
	_this->_parent->_refCount--;
}

// invoke
void array_each() {
	item = array_getAt();
	lambda->lambda(lambda->_parent, item);
}

// create
void sjf_anon2(sjs_func* _parent, int32_t i) {
	_parent->total += i;
}

x = new sjl_anon1
x->_refCount = 1;
x->_parent = _this;
x->_parent->_refCount++;
x->lambda = sjf_anon2;
array_each(arr, x);

-- library --
* directory structure for pure sj library
lib/common/common.sj
lib/common/array.sj
lib/common/string.sj
lib/common/tuple.sj

* directory structure for linked library
* link command: link "freetype.lib"
lib/freetype/freetype.sj
lib/freetype/freetype.h
lib/freetype/freetype.lib
lib/freetype/source/*